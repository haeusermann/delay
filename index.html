<!DOCTYPE html>
<html lang="en">
<head>
    <!-- 
        ============================================================
        DELAYED MIRROR - Progressive Web App
        ============================================================
        A video feedback app that displays camera feed with an 
        adjustable delay (10-120 seconds). Perfect for:
        - Sports training (golf swing, tennis serve analysis)
        - Dance practice and choreography review
        - Speech and presentation practice
        - Physical therapy exercises
        
        Features:
        - Adjustable delay via vertical slider (10-120 seconds)
        - Pinch-to-zoom functionality
        - Pan/drag to move zoomed video
        - Timer display showing current delay
        - Full PWA support for offline use
        ============================================================
    -->
    
    <meta charset="UTF-8">
    
    <!-- 
        VIEWPORT CONFIGURATION
        - width=device-width: Match screen width exactly
        - initial-scale=1.0: No initial zoom
        - maximum-scale=1.0: Prevent browser zoom (we handle zoom ourselves)
        - user-scalable=no: Disable pinch-zoom on page (we use it for video)
        - viewport-fit=cover: Use full screen on notched devices
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#0a0a0a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Delayed Mirror">
    <meta name="description" content="Video feedback with adjustable delay for training and practice">
    
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Apple Touch Icon for iOS home screen -->
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <title>Delayed Mirror</title>
    
    <!-- 
        ============================================================
        EMBEDDED STYLES
        ============================================================
        All styles are embedded for PWA offline functionality.
        The design uses a dark theme optimized for:
        - Reduced eye strain during practice sessions
        - Better contrast with video content
        - Professional appearance
        ============================================================
    -->
    <style>
        /* 
            CSS CUSTOM PROPERTIES (Variables)
            ---------------------------------
            Centralized values for easy customization.
            ADJUSTMENT: Change these values to modify the app's appearance.
        */
        :root {
            /* Color Palette - Dark theme with cyan accent */
            --color-bg: #0a0a0a;           /* Main background */
            --color-surface: #1a1a1a;       /* Elevated surfaces */
            --color-surface-hover: #252525; /* Hover state */
            --color-accent: #00d4aa;        /* Primary accent (cyan-green) */
            --color-accent-glow: rgba(0, 212, 170, 0.3); /* Glow effect */
            --color-text: #ffffff;          /* Primary text */
            --color-text-dim: #888888;      /* Secondary text */
            
            /* Spacing & Sizing */
            --slider-width: 48px;           /* ADJUSTMENT: Width of delay slider */
            --timer-size: 72px;             /* ADJUSTMENT: Timer display size */
            --border-radius: 12px;          /* Consistent rounded corners */
            
            /* Typography */
            --font-mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            
            /* Safe area insets for notched devices */
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
        }

        /* 
            RESET & BASE STYLES
            -------------------
            Normalize behavior across browsers and devices.
        */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Disable text selection to prevent interference with gestures */
            -webkit-user-select: none;
            user-select: none;
            /* Disable touch callouts (long-press menus) */
            -webkit-touch-callout: none;
        }

        html, body {
            height: 100%;
            /* Prevent pull-to-refresh and overscroll effects */
            overscroll-behavior: none;
            overflow: hidden;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            color: var(--color-text);
            /* Disable iOS tap highlight */
            -webkit-tap-highlight-color: transparent;
        }

        /* 
            MAIN CONTAINER
            --------------
            Full-screen layout using CSS Grid.
            The slider is positioned on the left, video fills the rest.
        */
        .app-container {
            display: grid;
            /* 
                ADJUSTMENT: Change slider-width to make the control panel wider/narrower
                The 1fr takes all remaining space for the video
            */
            grid-template-columns: var(--slider-width) 1fr;
            height: 100%;
            /* Account for safe areas on notched devices */
            padding-top: var(--safe-top);
            padding-bottom: var(--safe-bottom);
            padding-left: var(--safe-left);
        }

        /* 
            CONTROL PANEL (Left Side)
            -------------------------
            Contains the vertical delay slider.
            Dark surface with subtle styling.
        */
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--color-surface);
            padding: 16px 0;
            /* Subtle inner shadow for depth */
            box-shadow: inset -1px 0 0 rgba(255,255,255,0.05);
            position: relative;
            z-index: 10;
        }

        /* 
            VERTICAL SLIDER CONTAINER
            -------------------------
            The slider is rotated 90° to appear vertical.
            This is a common technique since HTML range inputs are horizontal by default.
        */
        .slider-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            /* 
                Fixed height for the slider track
                ADJUSTMENT: Change this to make the slider longer/shorter
                Set to 75% of viewport height for optimal reach on mobile
            */
            height: 75vh;
            max-height: 600px;
            min-height: 200px;
        }

        /* Min/Max labels at slider ends */
        .slider-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--color-text-dim);
            font-family: var(--font-mono);
        }

        /* 
            VERTICAL RANGE INPUT STYLING
            ----------------------------
            We rotate a horizontal slider to make it vertical.
            Width becomes height after rotation.
        */
        .delay-slider {
            /* 
                Writing mode trick: Makes the slider vertical natively in Firefox
                and provides better touch handling across browsers
            */
            writing-mode: vertical-lr;
            direction: rtl; /* Flip so higher values are at top */
            
            /* 
                ADJUSTMENT: This width becomes the visual height after rotation
                Set to 75vh minus labels to match container height
            */
            width: calc(75vh - 40px);
            max-width: 560px;
            min-width: 160px;
            
            height: 32px; /* This becomes the visual width */
            
            /* Remove default styling */
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            
            /* Allow touch gestures */
            touch-action: pan-y;
        }

        /* 
            SLIDER TRACK STYLING (WebKit browsers - Chrome, Safari, Edge)
            The track is the line the thumb slides along.
        */
        .delay-slider::-webkit-slider-runnable-track {
            /* 
                ADJUSTMENT: Change height for thicker/thinner track
            */
            height: 6px;
            background: linear-gradient(
                to top,
                var(--color-bg) 0%,
                var(--color-surface-hover) 100%
            );
            border-radius: 3px;
        }

        /* 
            SLIDER THUMB STYLING (WebKit)
            The draggable handle that sets the value.
        */
        .delay-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            /* 
                ADJUSTMENT: Change these dimensions for larger/smaller thumb
                Larger = easier to grab on touch screens
            */
            width: 28px;
            height: 28px;
            background: var(--color-accent);
            border-radius: 50%;
            border: none;
            /* Glow effect for visibility */
            box-shadow: 
                0 0 20px var(--color-accent-glow),
                0 2px 8px rgba(0,0,0,0.3);
            /* Center thumb on track */
            margin-top: -11px;
            /* Smooth transitions */
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        /* Enlarge thumb on hover/active for better feedback */
        .delay-slider::-webkit-slider-thumb:hover,
        .delay-slider::-webkit-slider-thumb:active {
            transform: scale(1.15);
            box-shadow: 
                0 0 30px var(--color-accent-glow),
                0 4px 12px rgba(0,0,0,0.4);
        }

        /* Firefox slider track styling */
        .delay-slider::-moz-range-track {
            height: 6px;
            background: linear-gradient(
                to top,
                var(--color-bg) 0%,
                var(--color-surface-hover) 100%
            );
            border-radius: 3px;
        }

        /* Firefox slider thumb styling */
        .delay-slider::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: var(--color-accent);
            border-radius: 50%;
            border: none;
            box-shadow: 
                0 0 20px var(--color-accent-glow),
                0 2px 8px rgba(0,0,0,0.3);
        }

        /* 
            VIDEO VIEWPORT
            --------------
            The main area where the delayed video is displayed.
            Handles overflow for zoom/pan functionality.
        */
        .video-viewport {
            position: relative;
            overflow: hidden;
            background: #000;
            /* Allow touch gestures for pan/zoom */
            touch-action: none;
        }

        /* 
            VIDEO WRAPPER
            -------------
            This div is transformed for zoom and pan.
            Contains the video element and receives transforms.
        */
        .video-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 
                Transform origin at center for intuitive zoom
                ADJUSTMENT: Change to zoom from a different point
            */
            transform-origin: center center;
            /* Smooth transitions for programmatic changes */
            transition: transform 0.1s ease-out;
        }

        /* 
            CANVAS ELEMENT
            --------------
            We use canvas instead of video for the delayed display.
            This allows frame-by-frame control of what's shown.
        */
        .delayed-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* 
                ADJUSTMENT: object-fit controls how video fills the space
                - 'cover': Fills entire space, may crop edges
                - 'contain': Shows entire video, may have black bars
            */
            max-width: 100%;
            max-height: 100%;
        }

        /* 
            TIMER DISPLAY
            -------------
            Shows the current delay setting overlaid on the video.
            Positioned at top-right corner.
        */
        .timer-display {
            position: absolute;
            /* 
                ADJUSTMENT: Change top/right values to reposition timer
            */
            top: 16px;
            right: 16px;
            /* 
                ADJUSTMENT: Change min-width for wider/narrower timer box
            */
            min-width: var(--timer-size);
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.75);
            /* Blur effect for modern glass look */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            z-index: 20;
        }

        .timer-value {
            /* 
                ADJUSTMENT: Change font-size for larger/smaller numbers
            */
            font-size: 28px;
            font-weight: 700;
            font-family: var(--font-mono);
            color: var(--color-accent);
            line-height: 1;
            /* Smooth color transitions */
            transition: color 0.3s ease;
        }

        .timer-unit {
            font-size: 11px;
            font-weight: 500;
            color: var(--color-text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        /* 
            ZOOM INDICATOR
            --------------
            Shows current zoom level, appears when zoomed in.
        */
        .zoom-indicator {
            position: absolute;
            bottom: 16px;
            right: 16px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 8px;
            font-size: 13px;
            font-family: var(--font-mono);
            color: var(--color-text-dim);
            z-index: 20;
            /* Hidden by default, shown when zoomed */
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .zoom-indicator.visible {
            opacity: 1;
        }

        /* 
            START SCREEN
            ------------
            Initial overlay prompting user to start camera.
            Required because browsers need user interaction for camera access.
        */
        .start-screen {
            position: fixed;
            inset: 0;
            background: var(--color-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 24px;
            /* Smooth fade out when starting */
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .start-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .start-icon {
            /* 
                ADJUSTMENT: Change size for larger/smaller icon
            */
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            color: var(--color-accent);
            /* Subtle animation to draw attention */
            animation: pulse 2s ease-in-out infinite;
        }

        /* 
            LOGO IMAGE
            ----------
            The app logo displayed on the start screen.
            ADJUSTMENT: Change max-width to resize the logo.
        */
        .start-logo {
            width: auto;
            height: auto;
            max-width: 280px;
            max-height: 280px;
            margin-bottom: 24px;
            /* Subtle animation to draw attention */
            animation: pulse 2s ease-in-out infinite;
            /* Smooth rounded edges to match logo design */
            border-radius: 50%;
            /* Add subtle shadow for depth */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        .start-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            text-align: center;
        }

        .start-subtitle {
            font-size: 14px;
            color: var(--color-text-dim);
            margin-bottom: 32px;
            text-align: center;
            max-width: 280px;
            line-height: 1.5;
        }

        .start-button {
            /* 
                ADJUSTMENT: Change padding for larger/smaller button
            */
            padding: 16px 48px;
            font-size: 16px;
            font-weight: 600;
            color: var(--color-bg);
            background: var(--color-accent);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            /* Touch-friendly sizing */
            min-height: 56px;
            /* Glow effect */
            box-shadow: 0 0 30px var(--color-accent-glow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .start-button:hover,
        .start-button:active {
            transform: scale(1.05);
            box-shadow: 0 0 40px var(--color-accent-glow);
        }

        /* 
            ERROR MESSAGE STYLING
            ---------------------
            Displayed when camera access fails.
        */
        .error-message {
            color: #ff6b6b;
            font-size: 14px;
            text-align: center;
            margin-top: 16px;
            max-width: 280px;
            display: none;
        }

        .error-message.visible {
            display: block;
        }

        /* 
            LOADING STATE
            -------------
            Shown while camera is initializing.
        */
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--color-surface);
            border-top-color: var(--color-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        .loading-spinner.visible {
            display: block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 
            BUFFER PROGRESS INDICATOR
            -------------------------
            Shows progress while the delay buffer is filling.
        */
        .buffer-indicator {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            text-align: center;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .buffer-indicator.visible {
            opacity: 1;
        }

        .buffer-text {
            font-size: 14px;
            color: var(--color-text-dim);
            margin-bottom: 8px;
        }

        .buffer-progress {
            width: 200px;
            height: 4px;
            background: var(--color-surface);
            border-radius: 2px;
            overflow: hidden;
        }

        .buffer-fill {
            height: 100%;
            background: var(--color-accent);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* 
            DOUBLE-TAP HINT
            ---------------
            Brief hint about double-tap to reset zoom.
        */
        .hint-toast {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            font-size: 13px;
            color: var(--color-text);
            z-index: 25;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
        }

        .hint-toast.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- 
        ============================================================
        START SCREEN
        ============================================================
        Shown on initial load. User must tap to start camera.
        This is required because browsers need a user gesture to 
        access the camera (security/privacy requirement).
    -->
    <div class="start-screen" id="startScreen">
        <!-- 
            LOGO IMAGE
            ----------
            The app logo is displayed here on the start screen.
            ADJUSTMENT: Replace logo.png with your own logo file.
        -->
        <img src="logo.png" alt="Häusermanns Video Feedback App" class="start-logo">
        
        <!-- Title removed since logo contains the app name -->
        
        <p class="start-subtitle">
            View yourself with an adjustable delay. 
            Perfect for training, practice, and form analysis.
        </p>
        
        <button class="start-button" id="startButton">
            Start Camera
        </button>
        
        <!-- Loading spinner (shown during camera init) -->
        <div class="loading-spinner" id="loadingSpinner"></div>
        
        <!-- Error message (shown if camera fails) -->
        <p class="error-message" id="errorMessage">
            Camera access denied. Please allow camera permissions and try again.
        </p>
    </div>

    <!-- 
        ============================================================
        MAIN APPLICATION CONTAINER
        ============================================================
        Two-column grid: controls on left, video on right.
    -->
    <div class="app-container">
        <!-- 
            CONTROL PANEL
            Contains the vertical delay slider.
        -->
        <div class="controls">
            <div class="slider-container">
                <!-- Maximum value label (top) -->
                <span class="slider-label">120s</span>
                
                <!-- 
                    DELAY SLIDER
                    ============
                    ADJUSTMENT POINTS:
                    - min: Minimum delay in seconds (default: 10)
                    - max: Maximum delay in seconds (default: 120)
                    - value: Initial delay value (default: 30)
                    - step: Increment amount (default: 1)
                -->
                <input 
                    type="range" 
                    class="delay-slider" 
                    id="delaySlider"
                    min="10"
                    max="120"
                    value="30"
                    step="1"
                    aria-label="Delay in seconds"
                >
                
                <!-- Minimum value label (bottom) -->
                <span class="slider-label">10s</span>
            </div>
        </div>

        <!-- 
            VIDEO VIEWPORT
            Main display area for the delayed video feed.
            Handles touch events for zoom and pan.
        -->
        <div class="video-viewport" id="videoViewport">
            <!-- 
                VIDEO WRAPPER
                This element receives transform for zoom/pan.
            -->
            <div class="video-wrapper" id="videoWrapper">
                <!-- 
                    DELAYED CANVAS
                    We draw frames from the buffer here.
                    Canvas gives us frame-by-frame control.
                -->
                <canvas class="delayed-canvas" id="delayedCanvas"></canvas>
            </div>

            <!-- 
                TIMER DISPLAY
                Shows current delay setting.
            -->
            <div class="timer-display">
                <div class="timer-value" id="timerValue">30</div>
                <div class="timer-unit">seconds</div>
            </div>

            <!-- 
                ZOOM INDICATOR
                Shows current zoom level.
            -->
            <div class="zoom-indicator" id="zoomIndicator">1.0×</div>

            <!-- 
                BUFFER PROGRESS
                Shows while delay buffer is filling.
            -->
            <div class="buffer-indicator" id="bufferIndicator">
                <div class="buffer-text">Buffering...</div>
                <div class="buffer-progress">
                    <div class="buffer-fill" id="bufferFill"></div>
                </div>
            </div>

            <!-- 
                HINT TOAST
                Shows brief usage hints.
            -->
            <div class="hint-toast" id="hintToast">
                Double-tap to reset zoom
            </div>
        </div>
    </div>

    <!-- Hidden video element for camera capture -->
    <video id="cameraVideo" playsinline autoplay muted style="display: none;"></video>

    <!-- 
        ============================================================
        JAVASCRIPT - Application Logic
        ============================================================
    -->
    <script>
        /**
         * ============================================================
         * DELAYED MIRROR - Main Application Script
         * ============================================================
         * 
         * ARCHITECTURE OVERVIEW:
         * ----------------------
         * 1. Camera capture → Hidden video element
         * 2. Frame capture → ImageData stored in circular buffer
         * 3. Delayed playback → Canvas rendering from buffer
         * 
         * The circular buffer stores frames based on:
         * - Target FPS (frames per second)
         * - Delay duration (in seconds)
         * - Buffer size = FPS × Delay
         * 
         * ADJUSTMENT POINTS are marked throughout with comments.
         * ============================================================
         */

        // ============================================================
        // DOM ELEMENT REFERENCES
        // ============================================================
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const errorMessage = document.getElementById('errorMessage');
        const delaySlider = document.getElementById('delaySlider');
        const timerValue = document.getElementById('timerValue');
        const cameraVideo = document.getElementById('cameraVideo');
        const delayedCanvas = document.getElementById('delayedCanvas');
        const videoViewport = document.getElementById('videoViewport');
        const videoWrapper = document.getElementById('videoWrapper');
        const zoomIndicator = document.getElementById('zoomIndicator');
        const bufferIndicator = document.getElementById('bufferIndicator');
        const bufferFill = document.getElementById('bufferFill');
        const hintToast = document.getElementById('hintToast');

        // ============================================================
        // CONFIGURATION CONSTANTS
        // ============================================================
        /**
         * ADJUSTMENT: TARGET_FPS
         * ----------------------
         * Frames per second for the delayed video.
         * Higher = smoother playback but more memory usage.
         * Lower = less smooth but saves memory.
         * 
         * Recommended values:
         * - 15: Good balance for most devices
         * - 24: Smoother, more memory
         * - 30: Very smooth, high memory
         * - 10: Low memory mode
         */
        const TARGET_FPS = 15;

        /**
         * ADJUSTMENT: ZOOM LIMITS
         * -----------------------
         * MIN_ZOOM: Minimum zoom level (1.0 = no zoom)
         * MAX_ZOOM: Maximum zoom level
         */
        const MIN_ZOOM = 1.0;
        const MAX_ZOOM = 5.0;

        /**
         * ADJUSTMENT: PAN FRICTION
         * ------------------------
         * How quickly pan momentum decays.
         * Higher = stops faster, Lower = slides more
         */
        const PAN_FRICTION = 0.92;

        // ============================================================
        // APPLICATION STATE
        // ============================================================
        let frameBuffer = [];           // Circular buffer for video frames
        let bufferIndex = 0;            // Current write position in buffer
        let isCapturing = false;        // Whether we're capturing frames
        let delaySeconds = 30;          // Current delay setting
        let captureContext = null;      // 2D context for frame capture
        let captureCanvas = null;       // Hidden canvas for frame capture
        let animationFrameId = null;    // ID for requestAnimationFrame
        let lastCaptureTime = 0;        // Timestamp of last frame capture

        // Zoom and pan state
        let currentZoom = 1.0;          // Current zoom level
        let panX = 0;                   // Current X pan offset
        let panY = 0;                   // Current Y pan offset
        let panVelocityX = 0;           // X velocity for momentum
        let panVelocityY = 0;           // Y velocity for momentum

        // Touch gesture state
        let initialPinchDistance = 0;   // Distance between fingers at pinch start
        let initialZoom = 1.0;          // Zoom level at pinch start
        let isPinching = false;         // Whether pinch gesture is active
        let isPanning = false;          // Whether pan gesture is active
        let lastTouchX = 0;             // Last touch X position
        let lastTouchY = 0;             // Last touch Y position
        let lastTapTime = 0;            // Time of last tap (for double-tap detection)
        let touchStartTime = 0;         // When touch started

        // ============================================================
        // INITIALIZATION
        // ============================================================

        /**
         * Initialize the application.
         * Sets up event listeners and default state.
         */
        function init() {
            // Set initial timer display
            timerValue.textContent = delaySlider.value;
            delaySeconds = parseInt(delaySlider.value);

            // Event listeners
            startButton.addEventListener('click', startCamera);
            delaySlider.addEventListener('input', handleDelayChange);

            // Touch gesture listeners
            videoViewport.addEventListener('touchstart', handleTouchStart, { passive: false });
            videoViewport.addEventListener('touchmove', handleTouchMove, { passive: false });
            videoViewport.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Prevent context menu on long press
            videoViewport.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // ============================================================
        // CAMERA FUNCTIONS
        // ============================================================

        /**
         * Start camera capture.
         * Requests camera access and initializes video stream.
         */
        async function startCamera() {
            // Show loading state
            startButton.style.display = 'none';
            loadingSpinner.classList.add('visible');
            errorMessage.classList.remove('visible');

            try {
                /**
                 * ADJUSTMENT: Camera constraints
                 * ------------------------------
                 * You can modify these to change camera behavior:
                 * - facingMode: 'user' (front) or 'environment' (back)
                 * - width/height: Resolution preferences
                 * - frameRate: Capture frame rate
                 */
                const constraints = {
                    video: {
                        facingMode: 'user',  // Front camera (selfie mode)
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                };

                // Request camera access
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraVideo.srcObject = stream;

                // Wait for video to be ready
                await new Promise((resolve) => {
                    cameraVideo.onloadedmetadata = () => {
                        cameraVideo.play();
                        resolve();
                    };
                });

                // Initialize capture canvas (hidden, used for frame extraction)
                captureCanvas = document.createElement('canvas');
                captureCanvas.width = cameraVideo.videoWidth;
                captureCanvas.height = cameraVideo.videoHeight;
                captureContext = captureCanvas.getContext('2d', { 
                    willReadFrequently: true  // Optimization hint for getImageData
                });

                // Set up display canvas
                delayedCanvas.width = cameraVideo.videoWidth;
                delayedCanvas.height = cameraVideo.videoHeight;

                // Initialize frame buffer
                initializeBuffer();

                // Hide start screen
                startScreen.classList.add('hidden');

                // Show buffer indicator
                bufferIndicator.classList.add('visible');

                // Start capture loop
                isCapturing = true;
                lastCaptureTime = performance.now();
                captureLoop();

                // Show hint after a short delay
                setTimeout(showHint, 2000);

            } catch (error) {
                console.error('Camera error:', error);
                loadingSpinner.classList.remove('visible');
                startButton.style.display = 'block';
                errorMessage.classList.add('visible');

                // Customize error message based on error type
                if (error.name === 'NotAllowedError') {
                    errorMessage.textContent = 'Camera access denied. Please allow camera permissions and try again.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage.textContent = 'No camera found. Please connect a camera and try again.';
                } else {
                    errorMessage.textContent = `Camera error: ${error.message}`;
                }
            }
        }

        /**
         * Initialize or resize the frame buffer.
         * Called on startup and when delay changes.
         */
        function initializeBuffer() {
            /**
             * Buffer size calculation:
             * We need to store enough frames to cover the delay duration.
             * 
             * ADJUSTMENT: You can modify TARGET_FPS to change quality vs memory:
             * - More FPS = smoother but more memory
             * - Less FPS = choppier but less memory
             * 
             * Memory usage estimate:
             * For 720p video at 15 FPS with 120s delay:
             * ~1280 × 720 × 4 bytes × 15 FPS × 120s ≈ 6.6 GB
             * 
             * To reduce memory, we store compressed frames or reduce resolution.
             * Currently using ImageData which is uncompressed.
             */
            const requiredFrames = Math.ceil(TARGET_FPS * delaySeconds);
            
            // Only resize if necessary
            if (frameBuffer.length !== requiredFrames) {
                // Create new buffer with correct size
                const newBuffer = new Array(requiredFrames).fill(null);
                
                // Copy existing frames if any (for smooth delay changes)
                if (frameBuffer.length > 0) {
                    const copyCount = Math.min(frameBuffer.length, requiredFrames);
                    for (let i = 0; i < copyCount; i++) {
                        const oldIndex = (bufferIndex - copyCount + i + frameBuffer.length) % frameBuffer.length;
                        newBuffer[i] = frameBuffer[oldIndex];
                    }
                    bufferIndex = Math.min(copyCount, requiredFrames - 1);
                } else {
                    bufferIndex = 0;
                }
                
                frameBuffer = newBuffer;
            }
        }

        // ============================================================
        // FRAME CAPTURE AND PLAYBACK
        // ============================================================

        /**
         * Main capture and playback loop.
         * Runs continuously using requestAnimationFrame.
         */
        function captureLoop() {
            if (!isCapturing) return;

            const now = performance.now();
            /**
             * ADJUSTMENT: Frame timing
             * ------------------------
             * We capture at TARGET_FPS regardless of display refresh rate.
             * This ensures consistent delay timing.
             */
            const frameInterval = 1000 / TARGET_FPS;
            const elapsed = now - lastCaptureTime;

            if (elapsed >= frameInterval) {
                // Capture current frame
                captureFrame();
                
                // Display delayed frame
                displayDelayedFrame();
                
                // Update buffer progress indicator
                updateBufferProgress();
                
                lastCaptureTime = now - (elapsed % frameInterval);
            }

            // Continue loop
            animationFrameId = requestAnimationFrame(captureLoop);
        }

        /**
         * Capture a single frame from the video.
         * Stores it in the circular buffer.
         */
        function captureFrame() {
            if (!captureContext || !cameraVideo.videoWidth) return;

            // Draw current video frame to hidden canvas
            captureContext.drawImage(cameraVideo, 0, 0);

            /**
             * Get pixel data from the canvas.
             * 
             * ADJUSTMENT: For lower memory usage, you could:
             * 1. Reduce resolution: Draw to a smaller canvas
             * 2. Use compression: Convert to JPEG blob (async)
             * 3. Skip frames: Capture every Nth frame
             */
            const imageData = captureContext.getImageData(
                0, 0,
                captureCanvas.width,
                captureCanvas.height
            );

            // Store in circular buffer
            frameBuffer[bufferIndex] = imageData;
            
            // Advance buffer index (wrap around)
            bufferIndex = (bufferIndex + 1) % frameBuffer.length;
        }

        /**
         * Display the appropriately delayed frame.
         * Reads from the circular buffer.
         */
        function displayDelayedFrame() {
            if (frameBuffer.length === 0) return;

            /**
             * Calculate which frame to display.
             * The delayed frame is at the opposite end of the buffer from
             * where we're currently writing.
             * 
             * For a buffer of size N with write index W:
             * - Frame at W is the newest (just captured)
             * - Frame at (W+1) % N is the oldest (delaySeconds ago)
             */
            const delayedIndex = bufferIndex; // This is actually the oldest frame
            const frame = frameBuffer[delayedIndex];

            if (frame) {
                // Draw the delayed frame to the display canvas
                const ctx = delayedCanvas.getContext('2d');
                ctx.putImageData(frame, 0, 0);
            }
        }

        /**
         * Update the buffer progress indicator.
         * Shows filling progress until buffer is full.
         */
        function updateBufferProgress() {
            // Count filled frames
            const filledFrames = frameBuffer.filter(f => f !== null).length;
            const progress = (filledFrames / frameBuffer.length) * 100;

            bufferFill.style.width = `${progress}%`;

            // Hide indicator when buffer is full
            if (progress >= 100) {
                setTimeout(() => {
                    bufferIndicator.classList.remove('visible');
                }, 500);
            } else {
                bufferIndicator.classList.add('visible');
            }
        }

        // ============================================================
        // DELAY CONTROL
        // ============================================================

        /**
         * Handle delay slider changes.
         * Updates display and resizes buffer.
         */
        function handleDelayChange(event) {
            delaySeconds = parseInt(event.target.value);
            timerValue.textContent = delaySeconds;

            // Reinitialize buffer with new size
            initializeBuffer();

            // Show buffer indicator while refilling
            bufferIndicator.classList.add('visible');
        }

        // ============================================================
        // ZOOM AND PAN GESTURES
        // ============================================================

        /**
         * Handle touch start event.
         * Detects pinch, pan, and double-tap gestures.
         */
        function handleTouchStart(event) {
            event.preventDefault();
            
            const touches = event.touches;
            touchStartTime = Date.now();

            if (touches.length === 2) {
                // Two fingers: Start pinch zoom
                isPinching = true;
                isPanning = false;
                initialPinchDistance = getPinchDistance(touches);
                initialZoom = currentZoom;
            } else if (touches.length === 1) {
                // One finger: Potential pan or double-tap
                isPanning = true;
                isPinching = false;
                lastTouchX = touches[0].clientX;
                lastTouchY = touches[0].clientY;

                // Check for double-tap
                const now = Date.now();
                /**
                 * ADJUSTMENT: Double-tap threshold
                 * --------------------------------
                 * Time in ms between taps to register as double-tap.
                 * Increase for slower taps, decrease for faster.
                 */
                const doubleTapThreshold = 300;
                
                if (now - lastTapTime < doubleTapThreshold) {
                    // Double-tap detected: Reset zoom
                    resetZoom();
                    lastTapTime = 0;
                } else {
                    lastTapTime = now;
                }

                // Stop any ongoing momentum
                panVelocityX = 0;
                panVelocityY = 0;
            }
        }

        /**
         * Handle touch move event.
         * Processes pinch zoom and pan gestures.
         */
        function handleTouchMove(event) {
            event.preventDefault();
            
            const touches = event.touches;

            if (isPinching && touches.length === 2) {
                // Process pinch zoom
                const currentDistance = getPinchDistance(touches);
                /**
                 * ADJUSTMENT: Zoom sensitivity
                 * ----------------------------
                 * The ratio directly sets new zoom level.
                 * Multiply by a factor < 1 for less sensitive zoom.
                 */
                const scale = currentDistance / initialPinchDistance;
                let newZoom = initialZoom * scale;

                // Clamp zoom to limits
                newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                
                setZoom(newZoom);
            } else if (isPanning && touches.length === 1 && currentZoom > 1) {
                // Process pan (only when zoomed in)
                const touch = touches[0];
                /**
                 * ADJUSTMENT: Pan speed
                 * ---------------------
                 * Divide deltaX/Y by currentZoom to make pan speed
                 * consistent regardless of zoom level.
                 */
                const deltaX = (touch.clientX - lastTouchX) / currentZoom;
                const deltaY = (touch.clientY - lastTouchY) / currentZoom;

                // Track velocity for momentum
                panVelocityX = deltaX;
                panVelocityY = deltaY;

                // Update pan position
                setPan(panX + deltaX, panY + deltaY);

                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }

        /**
         * Handle touch end event.
         * Applies momentum for smooth deceleration.
         */
        function handleTouchEnd(event) {
            if (isPinching) {
                isPinching = false;
                // Snap to 1.0 if very close
                if (currentZoom < 1.1) {
                    resetZoom();
                }
            }

            if (isPanning) {
                isPanning = false;
                // Apply momentum if there was significant velocity
                if (Math.abs(panVelocityX) > 1 || Math.abs(panVelocityY) > 1) {
                    applyMomentum();
                }
            }

            // Clear single touch detection for next gesture
            if (event.touches.length === 0) {
                // Check if it was a tap (short touch without much movement)
                const touchDuration = Date.now() - touchStartTime;
                if (touchDuration < 200) {
                    // Quick tap - keep lastTapTime for double-tap detection
                } else {
                    // Long press - reset double-tap detection
                    lastTapTime = 0;
                }
            }
        }

        /**
         * Calculate distance between two touch points.
         * Used for pinch zoom detection.
         */
        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /**
         * Set zoom level and update display.
         */
        function setZoom(zoom) {
            currentZoom = zoom;
            updateTransform();
            
            // Update zoom indicator
            zoomIndicator.textContent = `${zoom.toFixed(1)}×`;
            zoomIndicator.classList.toggle('visible', zoom > 1.05);
        }

        /**
         * Set pan position with bounds checking.
         */
        function setPan(x, y) {
            /**
             * ADJUSTMENT: Pan boundaries
             * --------------------------
             * Limit how far the user can pan based on zoom level.
             * At zoom 2x, they can pan up to 50% of the viewport in each direction.
             */
            const maxPan = ((currentZoom - 1) / currentZoom) * 50;
            
            panX = Math.max(-maxPan, Math.min(maxPan, x));
            panY = Math.max(-maxPan, Math.min(maxPan, y));
            
            updateTransform();
        }

        /**
         * Apply CSS transform for zoom and pan.
         */
        function updateTransform() {
            /**
             * Transform order matters:
             * 1. Scale (zoom)
             * 2. Translate (pan)
             * 
             * Using percentage for translate makes pan independent of element size.
             */
            videoWrapper.style.transform = `scale(${currentZoom}) translate(${panX}%, ${panY}%)`;
        }

        /**
         * Reset zoom and pan to default.
         * Animated for smooth transition.
         */
        function resetZoom() {
            currentZoom = 1.0;
            panX = 0;
            panY = 0;
            panVelocityX = 0;
            panVelocityY = 0;
            
            // Smooth transition
            videoWrapper.style.transition = 'transform 0.3s ease-out';
            updateTransform();
            
            // Remove transition after animation
            setTimeout(() => {
                videoWrapper.style.transition = 'transform 0.1s ease-out';
            }, 300);

            // Update indicator
            zoomIndicator.classList.remove('visible');
        }

        /**
         * Apply momentum to pan after touch release.
         * Creates smooth deceleration effect.
         */
        function applyMomentum() {
            if (Math.abs(panVelocityX) < 0.5 && Math.abs(panVelocityY) < 0.5) {
                return; // Stop when velocity is negligible
            }

            // Apply velocity to position
            setPan(panX + panVelocityX, panY + panVelocityY);

            // Apply friction to slow down
            panVelocityX *= PAN_FRICTION;
            panVelocityY *= PAN_FRICTION;

            // Continue momentum on next frame
            requestAnimationFrame(applyMomentum);
        }

        // ============================================================
        // UI HELPERS
        // ============================================================

        /**
         * Show a brief hint toast.
         */
        function showHint() {
            hintToast.classList.add('visible');
            setTimeout(() => {
                hintToast.classList.remove('visible');
            }, 3000);
        }

        // ============================================================
        // SERVICE WORKER REGISTRATION
        // ============================================================

        /**
         * Register the service worker for PWA functionality.
         * This enables offline use and home screen installation.
         */
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }

        // ============================================================
        // START APPLICATION
        // ============================================================
        init();
    </script>
</body>
</html>
